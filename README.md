#MACHINE PROJECT 

##SPECFICATIONS
Project Name : A Walk in the Sequence Park

Project Background: A Walk in the Math Park is a game concept that would aid in teaching
number sequences to learners. The objective of the game is for players to
reach the last tile (i.e., tile 50) by answering simple to difficult sequences
for every tile the player lands.

Mechanics :
1. The game can be played by 1 to 4 players.

2. Before the start of the game, players will decide on the game level.
    a. For Level 1, players will answer the next number or letter in the
    sequence.

    b. For Level 2, players will answer the next 2 numbers or letters in
    the sequence; and

    c. For Level 3, players will answer the next 2 numbers and letters
    (combination) in the sequence.

3. Once the players are ready, they will press a user-defined key to roll a
virtual die. (Note: Randomization of the die outcome is required. Refer
to the link provided in the next page for generating random numbers)

4. Players take turns rolling a single die to move their token by the
number of squares indicated by the die rolled.

5. The players follow a fixed route marked on the gameboard which
usually follows a boustrophedon (ox-plow) track from the bottom to
the top of the playing area, passing once through every square.

    a. For every tile a player lands on, the program will randomly
    generate an series (e.g., 1 3 5 7...) which the player will need to
    solve mentally.

        i. Signed whole numbers will only be accepted for the
        operands.

        ii. For numbers, the series can either be arithmetic or
        geometric in sequence. However, the values should not
        be too exponential in nature (i.e., the next number is
        either too high or too low to do mental math.)

        iii. When generating the series to solve, make sure to check
        and trap errors for division by 0 (since this is not allowed)

        iv. If the player gets the correct answer, the player will stay
        on that tile s/he landed on.

        v. Otherwise, if the player made a mistake, the player
        would move back 1 to 3 tiles back (penalty will be
        randomly generated by the program). If the penalty is
        more than the current position of the player... the player
        will automatically be ejected from the game.

##MY ALGORITHM (Work in progress)
###The Main Function 
Name: main()
Paremeter: Void
Returns: int (0 or 1 for the success of the program)
1. My program starts with the main function. 
2. It will print a welcoming message to the player/s using printf. 
3. The Main Function will ask for an input of the number of players. MINIMUM of 1, MAXIMUM of 4. Scanf and Printf to get and
prompt the player/s. This data will be stored in a variable called nNumberOfPlayers.
4. The Main Function will prompt the player/s to provide a game level difficulty. Minimum is 1 and Maximum is 3. This will be stored in a variable called nGameLevel.
5. The Main Function will then pass the nNumberOfPlayers variable and nGameLevel variable to the Gameplay Loop Function.
6. After the gameplay loop function returns a value, which is the player number winner, it then prints a congratulatory message.


###The Gameplay Loop Function
Name: int gameLoop(int nNumberOfPlayer, int GameLevel)
Paremeter: int nNumberOfPlayers, int nGameLevel
Returns: int (the player number winner)
1. Initialize the following variables: 
    a. Storing the current space number of a player and setting it to 1 or 0 this can be called nPlayer1 or nPlayer2. This depends on the nNumberOfPlayers and using Switch Case.
    b. A variable called nCurrentPlayerTurn that keeps track of which player's turn, set this equal to 1.
    c. A variable that keeps track of the number of players eliminated nNumberOfEliminated = 0.
    d. A variable  called nDieValue that stores the die value of a current turn 
    e. A variable that keeps track if a player has won already bPlayerWon = false
    f. A variable called cRoll that contains the ENTER or other character to roll the dice action
    g. A variable that stores a boolean value if a player answered correctly or not
2. This will be initialized in a while loop for the whole game loop (while bPlayerWon == false and while nNumberOfEliminated != nNumberOfPlayers)
    a. An if statement for each player's turn to skip eliminated player we use a helper function (if checkPlayer(nCurrentPlayer, nPlayer1, nPlayer2, nPlayer3, nPlayer4) > 0)
        i.Roll dice (This be done via a helper function called RollDie())
        ii.Answer the sequence question
            A. Create an external function called answerSequence() that return either the player answer correct or not
        iii.Move the player space
        iv.Ask the following if statements to figure out which nPlayer to move
            A. if nCurrentPlayer = 1 (nPlayer1 + or - the amount of space) and so on...
                1. Ask this if statement to update the number of eliminated players -> if nPlayer1 < 0 (nNumberOfEliminated++)
                2. Ask this if statement to see if the player already won if nPlayer1 == 50  (bPlayerWon = true)
    b. Ask the following if statements to update the current player
        i. if nCurrentPlayer == nNumberOfPlayers (nCurrentPlayer = 1)
        ii. else if nDieValue == 6 (nCurrentPlayerTurn += 0)
        iii. else (nCurrentPlayerTurn++)
3. Ask the following if statements
    a. if nNumberOfEliminated != nNumberOfPlayers (return 0 players won)
    b. else if bPlayerWon == true (return the player that won)

###Checking player eligibility for a turn function
Name: checkPlayer()
Paremeter: nCurrentPlayer, nPlayer1, nPlayer2, nPlayer3, nPlayer4
Returns: The current space of the current player either positive or 0 or negative
1. Use Switch Case to pair the two variables together

###Rolling the die function
Name: rollDie()
Parameter: void
Returns: a randonly generated int from 1 to 6

###Generating a sequence function
Name: answerSequence()
Parameter: nGameLevel
Returns: a boolean value whether the player is able to answer correctly or not
1. Declare some variables: 
    bool bCorrect - returns the value of true or false to indicate player'success (true or false)
    int nGenerate - indicates if either a numerical or alpha sequence will be generated (0 or 1)
    int nSequence - the number being added to the sequence (-10, 10)
    int nAnswer - the answer to the sequence
    int nAnswer2 - for difficulty 2 and 3
    int playerInput - the answer of the player
    char cAnswer - the answer to the sequence
    char cAnswer2 - for difficulty 2 and 3
    char playerInput - the answer of the player
2. Generate a random number between 0 and 1, thus 0 = numerical and 1 = alpha.

3. If numerical generate a random number for nFirst between (-50 to 50)
4. If alpha genearte a random char for cFirst between (A to Z)
5. If numerical or alpha generate a random number for nSequence between (-10 to 10)
6. Print message player...your question
7. Print message what is the next number in the sequence
8. Initialize a for (int i = 0; i < 5; i++)
    a. Initialize another for (int j = 0; j < nSequence; j++)
        i. nFirst or cFirst += 1
        ii. if cFirst > Z reset it to A
    b. printf nFirst or cFirst
9. Printf xx or xx xx for difficulty 2 or 3
10. nAnswer = nFirst + nSequence or
11. cAnswer = for (int i = 0; i < nSequence; i++)
    i. cFirst += 1
    ii if cFirst > Z reset it to A
    
12. return bCorrect

###Updating the answer helper function (Numerical)
Name: updateNumericalAnswer()
Parameter: int nSequence, int *nAnswer
Returns: Void (Only updates the pointer parameter)
    1. This function contains the loop for updating and printing out the current value of nAnswer.

###Updating the answer helper function (Alphabetical)
Name: updateAlphaAnswer()
Parameter: int nSequence, int nGameDifficulty, char *cAnswer, char *cAnswer2
Returns: Void (Only updates the pointer parameter)
    1. This function contains the conditions and picks the right loop to update the cAnswer and or cAnswer2.
##Notes Regarding issues and bugs
1. main()
    i. Bug 1 is unresolved
2. answerSequence
    i. Bug 1 is unresolved
    ii. Bug 2 is resolved 
    iii. Bug 3 is resolved.